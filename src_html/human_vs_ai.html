<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D 地块征服 - 人机对战</title>
  <style>
    :root {
      --bg-a: #0c1328;
      --bg-b: #1a1f37;
      --panel: rgba(12, 18, 34, 0.8);
      --line: rgba(133, 255, 246, 0.9);
      --text: #eaf2ff;
      --human: #3fd8ff;
      --neutral: #eaeaea;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      overflow: hidden;
      font-family: "Trebuchet MS", "PingFang SC", sans-serif;
      color: var(--text);
      background: radial-gradient(circle at 20% 10%, #213a66, var(--bg-a) 45%, var(--bg-b) 100%);
    }

    #app { position: fixed; inset: 0; }

    .hud {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: min(980px, 96vw);
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 10px;
      z-index: 5;
    }

    .card {
      min-width: 0;
      text-align: center;
      border: 1px solid rgba(170, 216, 255, 0.25);
      border-radius: 12px;
      background: var(--panel);
      backdrop-filter: blur(8px);
      padding: 8px 12px;
      font-size: 17px;
    }

    .card b { display: block; margin-top: 3px; font-size: 19px; }

    .color-chip {
      display: inline-block;
      width: 28px;
      height: 28px;
      border-radius: 8px;
      border: 2px solid rgba(255, 255, 255, 0.65);
      box-shadow: 0 0 0 2px rgba(10, 20, 38, 0.55);
      vertical-align: middle;
    }

    .game-controls {
      position: fixed;
      right: 14px;
      bottom: 14px;
      display: flex;
      gap: 8px;
      z-index: 5;
    }

    .ghost-btn {
      border-radius: 999px;
      border: 1px solid rgba(170, 216, 255, 0.2);
      background: var(--panel);
      color: #cfe7ff;
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 0.5px;
      padding: 9px 14px;
      cursor: pointer;
      backdrop-filter: blur(8px);
      margin-top: 0;
    }

    .ghost-btn:hover {
      transform: translateY(-1px);
      border-color: rgba(170, 216, 255, 0.38);
    }

    .panel.help-panel {
      width: min(720px, 100%);
      text-align: left;
      padding: 18px 20px;
    }

    .help-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }

    .help-title h2 {
      font-size: clamp(22px, 4vw, 34px);
    }

    .help-close {
      margin-top: 0;
      padding: 8px 14px;
      font-size: 14px;
    }

    .help-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
    }

    .help-item {
      border: 1px solid rgba(170, 216, 255, 0.22);
      border-radius: 12px;
      padding: 10px 12px;
      background: rgba(8, 14, 30, 0.5);
    }

    .help-item h3 {
      font-size: 16px;
      margin-bottom: 6px;
      color: #bfe4ff;
    }

    .help-item p {
      margin: 0;
      font-size: 14px;
      line-height: 1.45;
      opacity: 0.95;
    }

    .overlay {
      position: fixed;
      inset: 0;
      z-index: 9;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(7, 10, 21, 0.85);
      padding: 16px;
    }

    .panel {
      width: min(760px, 100%);
      border: 1px solid rgba(170, 216, 255, 0.3);
      border-radius: 16px;
      background: linear-gradient(160deg, rgba(29, 44, 75, 0.9), rgba(17, 15, 40, 0.9));
      box-shadow: 0 24px 80px rgba(0, 0, 0, 0.4);
      padding: 22px;
      text-align: center;
    }

    h1 { font-size: clamp(30px, 6vw, 56px); margin-bottom: 12px; }

    p { margin-top: 7px; line-height: 1.5; opacity: 0.94; }

    .config {
      margin: 14px auto 0;
      display: flex;
      justify-content: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    label {
      display: flex;
      gap: 8px;
      align-items: center;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(170, 216, 255, 0.18);
      border-radius: 9px;
      padding: 7px 10px;
    }

    input {
      width: 84px;
      background: rgba(0, 0, 0, 0.2);
      color: white;
      border: 1px solid rgba(170, 216, 255, 0.28);
      border-radius: 6px;
      padding: 4px 6px;
      font-size: 15px;
    }

    button {
      margin-top: 16px;
      border: 0;
      border-radius: 999px;
      font-size: 18px;
      font-weight: 700;
      padding: 11px 30px;
      cursor: pointer;
      color: #09253e;
      background: linear-gradient(90deg, #8af2ff, #87ff9f);
      transition: transform 0.15s;
    }

    button:hover { transform: scale(1.04); }
    .hidden { display: none; }

    .menu-actions {
      margin-top: 16px;
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .menu-secondary {
      color: #d8ebff;
      background: linear-gradient(120deg, #31557e, #2b3457);
    }

    @media (max-width: 768px) {
      .hud {
        top: 8px;
        width: calc(100vw - 16px);
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
      }

      .card {
        padding: 6px 8px;
        border-radius: 10px;
        font-size: 14px;
      }

      .card b {
        margin-top: 2px;
        font-size: 28px;
      }

      .color-chip {
        width: 24px;
        height: 24px;
        border-radius: 7px;
      }

      .game-controls {
        right: 8px;
        bottom: 8px;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .ghost-btn {
        font-size: 13px;
        padding: 8px 12px;
      }

      .panel.help-panel {
        padding: 14px;
      }

      .help-grid {
        grid-template-columns: 1fr;
        gap: 8px;
      }

      .help-item h3 {
        font-size: 15px;
      }

      .help-item p {
        font-size: 13px;
      }
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <div class="hud">
    <div class="card"><span id="stat1Label">你的地块</span><b id="stat1Value">0</b></div>
    <div class="card"><span id="stat2Label">你的总兵力</span><b id="stat2Value">0</b></div>
    <div class="card"><span id="stat3Label">行动点</span><b id="stat3Value">3/3</b></div>
    <div class="card"><span id="stat4Label">剩余玩家阵营</span><b id="stat4Value">0</b></div>
  </div>

  <div id="gameControls" class="game-controls hidden">
    <button id="pauseBtn" class="ghost-btn">暂停游戏</button>
    <button id="restartGameBtn" class="ghost-btn">重新开始</button>
    <button id="backHomeBtn" class="ghost-btn">返回主页</button>
  </div>

  <div id="homeOverlay" class="overlay">
    <div class="panel">
      <h1>3D 地块征服</h1>
      <p>随机生成地块，玩家或 AI 多方混战。</p>
      <p>默认规则：初始地块兵力 25，中立守军 15，占领地块每秒 +1 兵力。</p>
      <div class="menu-actions">
        <button id="humanModeBtn">人机对战</button>
        <button id="aiModeBtn">AI 对战</button>
        <button id="rulesBtn" class="menu-secondary">游戏说明</button>
      </div>
    </div>
  </div>

  <div id="configOverlay" class="overlay hidden">
    <div class="panel">
      <h1 id="configTitle">开始对局</h1>
      <p id="configDesc">调整参数后开始。</p>
      <div class="config">
        <label>地块数 n <input id="tileCountInput" type="number" min="8" max="200" value="24" /></label>
        <label><span id="playerCountLabel">玩家数 m</span><input id="playerCountInput" type="number" min="2" max="10" value="4" /></label>
      </div>
      <div class="menu-actions">
        <button id="startBtn">开始对局</button>
        <button id="cancelConfigBtn" class="menu-secondary">返回主页</button>
      </div>
    </div>
  </div>

  <div id="endOverlay" class="overlay hidden">
    <div class="panel">
      <h1 id="endTitle">对局结束</h1>
      <p id="endDesc"></p>
      <div class="menu-actions">
        <button id="restartBtn">再来一局</button>
        <button id="endHomeBtn" class="menu-secondary">返回主页</button>
      </div>
    </div>
  </div>

  <div id="rulesOverlay" class="overlay hidden">
    <div class="panel help-panel">
      <div class="help-title">
        <h2>游戏说明</h2>
        <button id="closeRulesBtn" class="help-close">返回主页</button>
      </div>
      <div class="help-grid">
        <div class="help-item">
          <h3>操作</h3>
          <p>长按自己的地块并拖动，经过己方地块可连选；松手后已选地块会向目标方向派兵。</p>
        </div>
        <div class="help-item">
          <h3>行动点</h3>
          <p>每名玩家有 3 点行动点。每次派兵消耗 1 点，每 3 秒恢复 1 点，最多恢复到 3 点。</p>
        </div>
        <div class="help-item">
          <h3>兵力与占领</h3>
          <p>己方地块每秒 +1 兵力。攻击非己方地块按 1:1 消耗，进攻兵力必须“超过”守军才会占领。</p>
        </div>
        <div class="help-item">
          <h3>特殊规则</h3>
          <p>首都（黄环）在原阵营持有时防守为 2:1；敌对在途行军颗粒相撞会按 1:1 抵消。</p>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { Line2 } from "three/examples/jsm/lines/Line2.js";
    import { LineGeometry } from "three/examples/jsm/lines/LineGeometry.js";
    import { LineMaterial } from "three/examples/jsm/lines/LineMaterial.js";

    const INITIAL_ARMY = 25;
    const NEUTRAL_INITIAL_ARMY = 15;
    const LONG_PRESS_MS = 180;
    const AI_THINK_INTERVAL = 0.28;
    const AI_RANDOM_START_DELAY_MAX_SEC = 3;
    const MOVE_CHARGE_MAX = 3;
    const MOVE_CHARGE_REGEN_SEC = 3;
    const HUMAN_COLOR = 0x3fd8ff;
    const TROOP_PACKET_SIZE = 4;
    const TROOP_MOVE_SPEED = 7;
    const CAPITAL_DEFENSE_MULT = 2;
    const TROOP_PACKET_WORLD_GAP = 1.2;
    const TROOP_PARTICLE_RADIUS_DESKTOP = 0.24;
    const TROOP_PARTICLE_RADIUS_MOBILE = 0.34;
    const LABEL_HEIGHT = 1.6;
    const TILE_RADIUS = 2.4;
    const TILE_MIN_GAP = 0.32;
    const TILE_PLACEMENT_RADIUS_PAD = 5.4;
    const TILE_MAX_SAFE_CAP = 180;

    const MODE_HUMAN_VS_AI = "human";
    const MODE_AI_VS_AI = "ai";

    const app = document.getElementById("app");
    const homeOverlay = document.getElementById("homeOverlay");
    const configOverlay = document.getElementById("configOverlay");
    const endOverlay = document.getElementById("endOverlay");
    const endTitle = document.getElementById("endTitle");
    const endDesc = document.getElementById("endDesc");
    const rulesOverlay = document.getElementById("rulesOverlay");
    const configTitle = document.getElementById("configTitle");
    const configDesc = document.getElementById("configDesc");
    const playerCountLabel = document.getElementById("playerCountLabel");
    const tileCountInput = document.getElementById("tileCountInput");
    const playerCountInput = document.getElementById("playerCountInput");
    const humanModeBtn = document.getElementById("humanModeBtn");
    const aiModeBtn = document.getElementById("aiModeBtn");
    const rulesBtn = document.getElementById("rulesBtn");
    const cancelConfigBtn = document.getElementById("cancelConfigBtn");
    const startBtn = document.getElementById("startBtn");
    const closeRulesBtn = document.getElementById("closeRulesBtn");
    const restartBtn = document.getElementById("restartBtn");
    const endHomeBtn = document.getElementById("endHomeBtn");
    const gameControls = document.getElementById("gameControls");
    const pauseBtn = document.getElementById("pauseBtn");
    const restartGameBtn = document.getElementById("restartGameBtn");
    const backHomeBtn = document.getElementById("backHomeBtn");

    const stat1Label = document.getElementById("stat1Label");
    const stat2Label = document.getElementById("stat2Label");
    const stat3Label = document.getElementById("stat3Label");
    const stat4Label = document.getElementById("stat4Label");
    const stat1Value = document.getElementById("stat1Value");
    const stat2Value = document.getElementById("stat2Value");
    const stat3Value = document.getElementById("stat3Value");
    const stat4Value = document.getElementById("stat4Value");

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(52, window.innerWidth / window.innerHeight, 0.1, 300);
    const CAMERA_OFFSET_DIR = new THREE.Vector3(0.01, 1, 0.01).normalize();
    camera.position.set(0, 42, 34);
    const cameraTarget = new THREE.Vector3(0, 0, 0);
    camera.lookAt(cameraTarget);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.domElement.style.touchAction = "none";
    app.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 1.25));

    const floor = new THREE.Mesh(
      new THREE.CircleGeometry(1, 60),
      new THREE.MeshStandardMaterial({ color: 0x1a2138, roughness: 0.9, metalness: 0.04 })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -0.02;
    scene.add(floor);

    const ring = new THREE.Mesh(
      new THREE.RingGeometry(1.03, 1.14, 64),
      new THREE.MeshBasicMaterial({ color: 0x36507d, transparent: true, opacity: 0.55, side: THREE.DoubleSide })
    );
    ring.rotation.x = -Math.PI / 2;
    ring.position.y = 0.03;
    scene.add(ring);

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2(2, 2);
    const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

    const tileGroup = new THREE.Group();
    const labelGroup = new THREE.Group();
    const troopGroup = new THREE.Group();
    scene.add(tileGroup);
    scene.add(labelGroup);
    scene.add(troopGroup);

    const pathMaterial = new LineMaterial({ color: 0x9df4ff, transparent: true, opacity: 0.5, linewidth: 5 });
    pathMaterial.resolution.set(window.innerWidth, window.innerHeight);
    const pathLines = [];
    let troopParticleGeometry = null;
    const troopMaterials = new Map();
    const troopMarches = [];
    const troopDispatchQueues = [];

    let gameStarted = false;
    let gameOver = false;
    let isPaused = false;
    let lastTime = 0;

    let gameMode = MODE_HUMAN_VS_AI;
    let tileCount = 24;
    let playerCount = 4;

    let players = [];
    let tiles = [];

    let growthTimer = 0;

    let pressing = false;
    let dragging = false;
    let pressStartTime = 0;
    let pressTile = null;
    let hoveredTile = null;
    let dragCursorPoint = null;
    let selectedTileIds = new Set();
    let mapRadius = 30;
    let cameraMinDist = 24;
    let cameraMaxDist = 78;
    let cameraBound = 34;
    let compactUI = window.innerWidth <= 768;

    function clampInt(v, min, max) {
      return Math.max(min, Math.min(max, Math.floor(v)));
    }

    function rebuildTroopParticleGeometry() {
      if (troopParticleGeometry) troopParticleGeometry.dispose();
      const radius = compactUI ? TROOP_PARTICLE_RADIUS_MOBILE : TROOP_PARTICLE_RADIUS_DESKTOP;
      troopParticleGeometry = new THREE.SphereGeometry(radius, 12, 12);
      for (const march of troopMarches) refreshTroopPacketMesh(march);
    }

    function getTilePlacementRadius() {
      return mapRadius + TILE_PLACEMENT_RADIUS_PAD;
    }

    function buildHexPackedPoints(radius, minCenterDist, rotation = 0) {
      const pts = [];
      const rowStep = minCenterDist * Math.sqrt(3) * 0.5;
      const maxRow = Math.ceil(radius / rowStep);
      const maxCol = Math.ceil(radius / minCenterDist) + 2;
      const cosR = Math.cos(rotation);
      const sinR = Math.sin(rotation);

      for (let row = -maxRow; row <= maxRow; row += 1) {
        const z = row * rowStep;
        const xOffset = (Math.abs(row) % 2) * (minCenterDist * 0.5);
        for (let col = -maxCol; col <= maxCol; col += 1) {
          const x = col * minCenterDist + xOffset;
          const rx = x * cosR - z * sinR;
          const rz = x * sinR + z * cosR;
          if (rx * rx + rz * rz <= radius * radius) {
            pts.push({ x: rx, z: rz });
          }
        }
      }

      return pts;
    }

    function getMaxTileCountByArea() {
      const placementRadius = getTilePlacementRadius();
      const minCenterDist = TILE_RADIUS * 2 + TILE_MIN_GAP;
      const packed = buildHexPackedPoints(placementRadius, minCenterDist, 0);
      return Math.max(8, Math.min(TILE_MAX_SAFE_CAP, packed.length));
    }

    function refreshTileLimitUI() {
      const maxTiles = getMaxTileCountByArea();
      tileCountInput.max = String(maxTiles);
      tileCount = clampInt(tileCount, 8, maxTiles);
      if (Number(tileCountInput.value || 0) > maxTiles || !tileCountInput.value) {
        tileCountInput.value = String(tileCount);
      }
      if (playerCount > tileCount) {
        playerCount = tileCount;
        playerCountInput.value = String(playerCount);
      }
    }

    function hasHumanPlayer() {
      return gameMode === MODE_HUMAN_VS_AI;
    }

    function paintArmyLabel(ctx, canvas, value, ownerColor) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = ownerColor || "#ffffff";
      if (compactUI) {
        ctx.shadowColor = "rgba(0,0,0,0.65)";
        ctx.shadowBlur = 10;
        ctx.font = "700 140px Trebuchet MS";
        ctx.fillText(value, 128, 64);
        ctx.shadowBlur = 0;
        return;
      }

      ctx.shadowColor = "rgba(0,0,0,0.48)";
      ctx.shadowBlur = 7;
      ctx.font = "700 72px Trebuchet MS";
      ctx.fillText(value, 128, 64);
      ctx.shadowBlur = 0;
    }

    function updateMapLayout(recenter = false) {
      mapRadius = THREE.MathUtils.clamp(Math.min(window.innerWidth, window.innerHeight) / 34, 18, 34);
      floor.scale.set(mapRadius + 8, mapRadius + 8, 1);
      ring.scale.set(mapRadius + 10, mapRadius + 10, 1);

      const vHalf = THREE.MathUtils.degToRad(camera.fov * 0.5);
      const hHalf = Math.atan(Math.tan(vHalf) * camera.aspect);
      const fitHalf = Math.max(0.25, Math.min(vHalf, hHalf));
      const fitDist = (mapRadius * 1.25) / Math.tan(fitHalf);

      cameraMinDist = fitDist;
      cameraMaxDist = fitDist * 2.6;
      cameraBound = mapRadius + 6;

      if (recenter) {
        cameraTarget.set(0, 0, 0);
        camera.position.copy(cameraTarget).addScaledVector(CAMERA_OFFSET_DIR, fitDist * 1.2);
      }
      clampCamera();
    }

    function clampCamera() {
      cameraTarget.x = THREE.MathUtils.clamp(cameraTarget.x, -cameraBound, cameraBound);
      cameraTarget.z = THREE.MathUtils.clamp(cameraTarget.z, -cameraBound, cameraBound);
      const offset = camera.position.clone().sub(cameraTarget);
      const dist = THREE.MathUtils.clamp(offset.length(), cameraMinDist, cameraMaxDist);
      offset.setLength(dist);
      camera.position.copy(cameraTarget).add(offset);
      camera.lookAt(cameraTarget);
    }

    function makeLabelSprite(text) {
      const canvas = document.createElement("canvas");
      canvas.width = 256;
      canvas.height = 128;
      const ctx = canvas.getContext("2d");
      paintArmyLabel(ctx, canvas, text, "rgba(170,220,255,0.6)");

      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      const material = new THREE.SpriteMaterial({
        map: texture,
        depthWrite: false,
        depthTest: false,
        transparent: true,
      });
      const sprite = new THREE.Sprite(material);
      sprite.center.set(0.5, 0.5);
      sprite.scale.set(compactUI ? 4.6 : 4.2, compactUI ? 2.2 : 2.1, 1);
      sprite.userData.canvas = canvas;
      sprite.userData.ctx = ctx;
      sprite.userData.texture = texture;
      return sprite;
    }

    function updateLabel(tile) {
      const { canvas, ctx, texture } = tile.label.userData;
      const owner = tile.owner;
      const ownerColor = owner === -1 ? "#f0f0f0" : `#${new THREE.Color(players[owner].color).getHexString()}`;
      paintArmyLabel(ctx, canvas, String(Math.floor(tile.army)), ownerColor);
      tile.label.scale.set(compactUI ? 4.6 : 4.2, compactUI ? 2.2 : 2.1, 1);
      texture.needsUpdate = true;
    }

    function createTiles() {
      tileGroup.clear();
      labelGroup.clear();
      for (const line of pathLines) scene.remove(line);
      pathLines.length = 0;

      tiles = [];
      const placementRadius = getTilePlacementRadius();
      const minCenterDist = TILE_RADIUS * 2 + TILE_MIN_GAP;
      const packedPoints = buildHexPackedPoints(placementRadius, minCenterDist, Math.random() * (Math.PI / 3));

      for (let i = packedPoints.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [packedPoints[i], packedPoints[j]] = [packedPoints[j], packedPoints[i]];
      }

      tileCount = Math.min(tileCount, packedPoints.length);
      tileCountInput.value = String(tileCount);

      for (let i = 0; i < tileCount; i += 1) {
        const { x, z } = packedPoints[i];

        const mesh = new THREE.Mesh(
          new THREE.CylinderGeometry(2, 2.4, 1.2, 28),
          new THREE.MeshStandardMaterial({
            color: 0xeaeaea,
            roughness: 0.55,
            metalness: 0.15,
            emissive: 0x000000,
            emissiveIntensity: 0,
          })
        );
        mesh.position.set(x, 0.62, z);
        mesh.castShadow = false;
        mesh.receiveShadow = true;
        tileGroup.add(mesh);

        const label = makeLabelSprite(String(INITIAL_ARMY));
        label.position.set(x, LABEL_HEIGHT, z);
        labelGroup.add(label);

        const capitalMarker = new THREE.Mesh(
          new THREE.TorusGeometry(1.05, 0.1, 10, 20),
          new THREE.MeshStandardMaterial({
            color: 0xffd86f,
            emissive: 0xffd86f,
            emissiveIntensity: 0.15,
            roughness: 0.45,
            metalness: 0.3,
          })
        );
        capitalMarker.position.set(x, 1.45, z);
        capitalMarker.rotation.x = Math.PI / 2;
        capitalMarker.visible = false;
        tileGroup.add(capitalMarker);

        const tile = {
          id: i,
          owner: -1,
          army: INITIAL_ARMY,
          reservedArmy: 0,
          mesh,
          label,
          isCapital: false,
          capitalOwner: -1,
          capitalMarker,
        };

        mesh.userData.tileId = i;
        capitalMarker.userData.tileId = i;
        tiles.push(tile);
      }
    }

    function createPlayers() {
      players = [];
      const aiColors = [];
      const aiCount = hasHumanPlayer() ? Math.max(0, playerCount - 1) : playerCount;
      const hueOffset = Math.random();
      for (let i = 0; i < aiCount; i += 1) {
        const hue = (hueOffset + i / Math.max(1, aiCount)) % 1;
        const sat = 0.62 + Math.random() * 0.2;
        const light = 0.5 + Math.random() * 0.1;
        aiColors.push(new THREE.Color().setHSL(hue, sat, light).getHex());
      }

      for (let i = 0; i < playerCount; i += 1) {
        const isHuman = hasHumanPlayer() && i === 0;
        players.push({
          id: i,
          isHuman,
          color: isHuman ? HUMAN_COLOR : aiColors[hasHumanPlayer() ? i - 1 : i],
          aiTimer: 0,
          aiStartDelay: isHuman ? 0 : Math.random() * AI_RANDOM_START_DELAY_MAX_SEC,
          moveCharges: MOVE_CHARGE_MAX,
          moveRegenTimer: 0,
        });
      }
    }

    function resetOwnership() {
      for (const tile of tiles) {
        tile.owner = -1;
        tile.army = NEUTRAL_INITIAL_ARMY;
        tile.reservedArmy = 0;
        tile.isCapital = false;
        tile.capitalOwner = -1;
        tile.capitalMarker.visible = false;
      }

      const idxs = Array.from({ length: tiles.length }, (_, i) => i);
      for (let i = idxs.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [idxs[i], idxs[j]] = [idxs[j], idxs[i]];
      }

      for (let p = 0; p < playerCount; p += 1) {
        const t = tiles[idxs[p]];
        t.owner = p;
        t.army = INITIAL_ARMY;
        t.isCapital = true;
        t.capitalOwner = p;
        t.capitalMarker.visible = true;
      }

      applyVisuals();
    }

    function applyVisuals() {
      for (const tile of tiles) {
        const mat = tile.mesh.material;
        const isNeutral = tile.owner === -1;
        const color = isNeutral ? 0xeaeaea : players[tile.owner].color;
        mat.color.setHex(color);
        mat.emissive.setHex(0x000000);
        mat.emissiveIntensity = 0;
        tile.mesh.scale.set(1, 1, 1);
        updateLabel(tile);
      }
    }

    function updateHud() {
      let humanTerritory = 0;
      let humanArmy = 0;
      const aliveFactions = new Set();
      const territoryByOwner = new Map();
      const armyByOwner = new Map();

      for (const tile of tiles) {
        if (tile.owner >= 0) aliveFactions.add(tile.owner);
        if (tile.owner >= 0) {
          territoryByOwner.set(tile.owner, (territoryByOwner.get(tile.owner) || 0) + 1);
          armyByOwner.set(tile.owner, (armyByOwner.get(tile.owner) || 0) + Math.floor(tile.army));
        }
        if (tile.owner === 0) {
          humanTerritory += 1;
          humanArmy += Math.floor(tile.army);
        }
      }

      if (hasHumanPlayer()) {
        const myColor = `#${new THREE.Color(players[0]?.color || HUMAN_COLOR).getHexString()}`;
        stat1Label.textContent = "你的颜色";
        stat2Label.textContent = "你的总兵力";
        stat3Label.textContent = "行动点";
        stat4Label.textContent = "剩余玩家阵营";
        stat1Value.innerHTML = `<span class="color-chip" style="background:${myColor};"></span>`;
        stat2Value.textContent = String(humanArmy);
        stat3Value.textContent = `${players[0] ? players[0].moveCharges : 0}/${MOVE_CHARGE_MAX}`;
        stat4Value.textContent = String(aliveFactions.size);
        return;
      }

      let leaderId = -1;
      let leaderArmy = -1;
      for (const [ownerId, army] of armyByOwner.entries()) {
        if (army > leaderArmy) {
          leaderArmy = army;
          leaderId = ownerId;
        }
      }

      stat1Label.textContent = "AI 数量";
      stat2Label.textContent = "领先 AI";
      stat3Label.textContent = "领先兵力";
      stat4Label.textContent = "剩余阵营";
      stat1Value.textContent = String(playerCount);
      stat2Value.textContent = leaderId >= 0 ? `#${leaderId + 1}` : "-";
      stat3Value.textContent = leaderArmy >= 0 ? String(leaderArmy) : "0";
      stat4Value.textContent = String(aliveFactions.size);
    }

    function getTileFromPointer(clientX, clientY) {
      pointer.x = (clientX / window.innerWidth) * 2 - 1;
      pointer.y = -(clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(tileGroup.children, false);
      for (const hit of hits) {
        const id = hit.object?.userData?.tileId;
        if (Number.isInteger(id)) return tiles[id] || null;
      }
      return null;
    }

    function getGroundPointFromPointer(clientX, clientY) {
      pointer.x = (clientX / window.innerWidth) * 2 - 1;
      pointer.y = -(clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const out = new THREE.Vector3();
      return raycaster.ray.intersectPlane(groundPlane, out) ? out : null;
    }

    function clearSelection() {
      selectedTileIds.clear();
      hoveredTile = null;
      dragCursorPoint = null;
      pressTile = null;
      pressing = false;
      dragging = false;
      for (const line of pathLines) scene.remove(line);
      pathLines.length = 0;
    }

    function refreshSelectionVisuals() {
      for (const tile of tiles) {
        const mat = tile.mesh.material;
        if (selectedTileIds.has(tile.id)) {
          mat.emissive.setHex(0x7af8ff);
          mat.emissiveIntensity = 0.45;
          tile.mesh.scale.set(1.08, 1.12, 1.08);
        } else if (hoveredTile && hoveredTile.id === tile.id) {
          mat.emissive.setHex(0x8fd5ff);
          mat.emissiveIntensity = dragging ? 0.25 : 0.35;
          tile.mesh.scale.set(1.05, 1.08, 1.05);
        } else {
          mat.emissive.setHex(0x000000);
          mat.emissiveIntensity = 0;
          tile.mesh.scale.set(1, 1, 1);
        }
      }
    }

    function updatePathLines() {
      for (const line of pathLines) scene.remove(line);
      pathLines.length = 0;

      if (!dragging || selectedTileIds.size === 0) return;
      const targetPoint = dragCursorPoint
        ? new THREE.Vector3(dragCursorPoint.x, 2.3, dragCursorPoint.z)
        : hoveredTile
          ? new THREE.Vector3(hoveredTile.mesh.position.x, 2.3, hoveredTile.mesh.position.z)
          : null;
      if (!targetPoint) return;

      for (const id of selectedTileIds) {
        const from = tiles[id];
        const geo = new LineGeometry();
        geo.setPositions([
          from.mesh.position.x, 2.3, from.mesh.position.z,
          targetPoint.x, targetPoint.y, targetPoint.z,
        ]);
        const line = new Line2(geo, pathMaterial);
        line.computeLineDistances();
        pathLines.push(line);
        scene.add(line);
      }
    }

    function applyVisualOwner(tile) {
      const mat = tile.mesh.material;
      const isNeutral = tile.owner === -1;
      const color = isNeutral ? 0xeaeaea : players[tile.owner].color;
      mat.color.setHex(color);
    }

    function getTroopMaterial(attackerId) {
      const key = String(attackerId);
      if (!troopMaterials.has(key)) {
        troopMaterials.set(
          key,
          new THREE.MeshStandardMaterial({
            color: players[attackerId].color,
            emissive: players[attackerId].color,
            emissiveIntensity: 0.3,
            roughness: 0.4,
            metalness: 0.05,
          })
        );
      }
      return troopMaterials.get(key);
    }

    function createTroopPacket(attackerId, unitCount) {
      const group = new THREE.Group();
      const spacing = 0.34;
      const startX = -((unitCount - 1) * spacing) * 0.5;
      const material = getTroopMaterial(attackerId);

      for (let i = 0; i < unitCount; i += 1) {
        const dot = new THREE.Mesh(troopParticleGeometry, material);
        dot.position.set(startX + i * spacing, 0, 0);
        group.add(dot);
      }

      return group;
    }

    function refreshTroopPacketMesh(march) {
      march.mesh.clear();
      const spacing = 0.34;
      const startX = -((march.units - 1) * spacing) * 0.5;
      const material = getTroopMaterial(march.attackerId);
      for (let i = 0; i < march.units; i += 1) {
        const dot = new THREE.Mesh(troopParticleGeometry, material);
        dot.position.set(startX + i * spacing, 0, 0);
        march.mesh.add(dot);
      }
    }

    function clearTroopMarches() {
      troopMarches.length = 0;
      troopDispatchQueues.length = 0;
      troopGroup.clear();
      for (const mat of troopMaterials.values()) mat.dispose();
      troopMaterials.clear();
    }

    function queueTroopMarch(attackerId, fromTile, targetTile, units) {
      const start = new THREE.Vector3(fromTile.mesh.position.x, 2.05, fromTile.mesh.position.z);
      const end = new THREE.Vector3(targetTile.mesh.position.x, 2.05, targetTile.mesh.position.z);
      const dist = start.distanceTo(end);
      const baseTravel = Math.max(0.48, dist / TROOP_MOVE_SPEED);
      const mesh = createTroopPacket(attackerId, units);
      mesh.position.copy(start);
      mesh.rotation.y = Math.atan2(end.x - start.x, end.z - start.z);
      troopGroup.add(mesh);

      troopMarches.push({
        attackerId,
        targetTileId: targetTile.id,
        units,
        start,
        end,
        elapsed: 0,
        travelTime: baseTravel,
        mesh,
      });
    }

    function updateTroopDispatchQueues(dt) {
      for (let i = troopDispatchQueues.length - 1; i >= 0; i -= 1) {
        const q = troopDispatchQueues[i];
        const fromTile = q.fromTile;
        const targetTile = q.targetTile;

        if (!fromTile || !targetTile || q.remainingUnits <= 0 || fromTile.owner !== q.attackerId) {
          if (fromTile) fromTile.reservedArmy = Math.max(0, fromTile.reservedArmy - q.remainingUnits);
          troopDispatchQueues.splice(i, 1);
          continue;
        }

        q.cooldown -= dt;
        while (q.cooldown <= 0 && q.remainingUnits > 0) {
          const packetUnits = Math.min(TROOP_PACKET_SIZE, q.remainingUnits, Math.floor(fromTile.army));
          if (packetUnits <= 0) {
            fromTile.reservedArmy = Math.max(0, fromTile.reservedArmy - q.remainingUnits);
            q.remainingUnits = 0;
            break;
          }

          fromTile.army -= packetUnits;
          fromTile.reservedArmy = Math.max(0, fromTile.reservedArmy - packetUnits);
          q.remainingUnits -= packetUnits;
          updateLabel(fromTile);
          queueTroopMarch(q.attackerId, fromTile, targetTile, packetUnits);
          q.cooldown += q.launchInterval;
        }

        if (q.remainingUnits <= 0) {
          troopDispatchQueues.splice(i, 1);
        }
      }
    }

    function resolveTroopArrival(march) {
      const targetTile = tiles[march.targetTileId];
      if (!targetTile) return;

      if (targetTile.owner === march.attackerId) {
        targetTile.army += march.units;
      } else {
        const defendMult =
          targetTile.isCapital && targetTile.owner === targetTile.capitalOwner ? CAPITAL_DEFENSE_MULT : 1;
        const required = targetTile.army * defendMult;

        if (march.units > required) {
          targetTile.owner = march.attackerId;
          targetTile.army = march.units - required;
          targetTile.reservedArmy = 0;
          applyVisualOwner(targetTile);
        } else {
          targetTile.army = Math.max(0, targetTile.army - march.units / defendMult);
        }
      }

      updateLabel(targetTile);
    }

    function updateTroopMarches(dt) {
      for (const march of troopMarches) {
        march.elapsed += dt;
        const t = Math.min(1, march.elapsed / march.travelTime);
        march.mesh.position.lerpVectors(march.start, march.end, t);
        march.mesh.position.y = march.start.y;
      }

      // Flat route collision: enemy marching packets cancel 1:1 by particle count.
      for (let i = 0; i < troopMarches.length; i += 1) {
        const a = troopMarches[i];
        if (a.units <= 0) continue;
        for (let j = i + 1; j < troopMarches.length; j += 1) {
          const b = troopMarches[j];
          if (b.units <= 0 || a.attackerId === b.attackerId) continue;
          if (a.mesh.position.distanceTo(b.mesh.position) > 0.82) continue;

          const canceled = Math.min(a.units, b.units);
          if (canceled <= 0) continue;
          a.units -= canceled;
          b.units -= canceled;
          if (a.units > 0) refreshTroopPacketMesh(a);
          if (b.units > 0) refreshTroopPacketMesh(b);
        }
      }

      for (let i = troopMarches.length - 1; i >= 0; i -= 1) {
        const march = troopMarches[i];
        if (march.units <= 0) {
          troopGroup.remove(march.mesh);
          troopMarches.splice(i, 1);
          continue;
        }
        if (march.elapsed >= march.travelTime) {
          resolveTroopArrival(march);
          troopGroup.remove(march.mesh);
          troopMarches.splice(i, 1);
        }
      }
    }

    function sendTroops(attackerId, orders, targetTile) {
      let hasSent = false;
      for (const order of orders) {
        const fromTile = order.tile;
        if (!fromTile || fromTile.owner !== attackerId) continue;
        const freeArmy = Math.max(0, Math.floor(fromTile.army - fromTile.reservedArmy));
        const units = Math.min(freeArmy, Math.floor(order.units));
        if (units <= 0) continue;

        fromTile.reservedArmy += units;
        const launchInterval = Math.max(0.08, TROOP_PACKET_WORLD_GAP / TROOP_MOVE_SPEED);
        troopDispatchQueues.push({
          attackerId,
          fromTile,
          targetTile,
          remainingUnits: units,
          launchInterval,
          cooldown: 0,
        });
        hasSent = true;
      }
      return hasSent;
    }

    function tryConsumeMoveCharge(playerId) {
      const p = players[playerId];
      if (!p || p.moveCharges <= 0) return false;
      p.moveCharges -= 1;
      return true;
    }

    function humanSend() {
      if (!dragging || !hoveredTile || selectedTileIds.size === 0) return;
      const orders = [];
      for (const id of selectedTileIds) {
        const tile = tiles[id];
        if (tile.owner === 0 && tile.army > 0) {
          orders.push({ tile, units: Math.floor(tile.army) });
        }
      }
      if (orders.length === 0) return;
      if (!tryConsumeMoveCharge(0)) return;
      const sent = sendTroops(0, orders, hoveredTile);
      if (!sent) players[0].moveCharges = Math.min(MOVE_CHARGE_MAX, players[0].moveCharges + 1);
    }

    function aiThink(dt) {
      const startIndex = hasHumanPlayer() ? 1 : 0;
      for (let i = startIndex; i < players.length; i += 1) {
        const p = players[i];
        if (p.aiStartDelay > 0) {
          p.aiStartDelay = Math.max(0, p.aiStartDelay - dt);
          continue;
        }
        p.aiTimer += dt;
        if (p.aiTimer < AI_THINK_INTERVAL) continue;

        p.aiTimer = 0;
        if (p.moveCharges <= 0) continue;

        const ownTiles = tiles.filter((t) => t.owner === p.id && (t.army - t.reservedArmy) >= 8);
        if (ownTiles.length === 0) continue;

        ownTiles.sort((a, b) => b.army - a.army);
        const from = ownTiles[0];

        const candidates = tiles.filter((t) => t.owner !== p.id);
        if (candidates.length === 0) continue;

        let target = candidates[0];
        let bestScore = -Infinity;

        for (const c of candidates) {
          const dx = c.mesh.position.x - from.mesh.position.x;
          const dz = c.mesh.position.z - from.mesh.position.z;
          const dist = Math.sqrt(dx * dx + dz * dz);
          const weakBonus = Math.max(0, 40 - c.army);
          const neutralBonus = c.owner === -1 ? 7 : 0;
          const score = weakBonus + neutralBonus - dist * 0.7;
          if (score > bestScore) {
            bestScore = score;
            target = c;
          }
        }

        const freeArmy = Math.max(0, from.army - from.reservedArmy);
        const sendCount = Math.max(1, Math.floor(freeArmy * THREE.MathUtils.randFloat(0.55, 1.0)));
        if (!tryConsumeMoveCharge(p.id)) continue;
        const sent = sendTroops(p.id, [{ tile: from, units: sendCount }], target);
        if (!sent) p.moveCharges = Math.min(MOVE_CHARGE_MAX, p.moveCharges + 1);
      }
    }

    function regenMoveCharges(dt) {
      for (const p of players) {
        if (p.moveCharges >= MOVE_CHARGE_MAX) {
          p.moveRegenTimer = 0;
          continue;
        }
        p.moveRegenTimer += dt;
        while (p.moveRegenTimer >= MOVE_CHARGE_REGEN_SEC && p.moveCharges < MOVE_CHARGE_MAX) {
          p.moveRegenTimer -= MOVE_CHARGE_REGEN_SEC;
          p.moveCharges += 1;
        }
      }
    }

    function growArmy(dt) {
      growthTimer += dt;
      while (growthTimer >= 1) {
        growthTimer -= 1;
        for (const tile of tiles) {
          if (tile.owner >= 0) {
            tile.army += 1;
            updateLabel(tile);
          } else if (tile.owner === -1 && tile.army < NEUTRAL_INITIAL_ARMY) {
            tile.army = Math.min(NEUTRAL_INITIAL_ARMY, tile.army + 1);
            updateLabel(tile);
          }
        }
      }
    }

    function checkGameState() {
      if (!hasHumanPlayer()) {
        const aliveFactions = new Set();
        for (const tile of tiles) {
          if (tile.owner >= 0) aliveFactions.add(tile.owner);
        }
        for (const march of troopMarches) {
          if (march.units > 0) aliveFactions.add(march.attackerId);
        }

        if (aliveFactions.size <= 1) {
          gameOver = true;
          isPaused = false;
          const winnerId = aliveFactions.size === 1 ? Array.from(aliveFactions)[0] : -1;
          endTitle.textContent = "AI 对战结束";
          endDesc.textContent = winnerId >= 0 ? `获胜阵营：AI #${winnerId + 1}` : "无人获胜。";
          endOverlay.classList.remove("hidden");
        }
        return;
      }

      const humanTiles = tiles.filter((t) => t.owner === 0).length;
      const humanFieldArmy = tiles.reduce((sum, t) => sum + (t.owner === 0 ? t.army : 0), 0);
      const humanMarchingArmy = troopMarches.reduce((sum, m) => sum + (m.attackerId === 0 ? m.units : 0), 0);
      const humanTotalArmy = humanFieldArmy + humanMarchingArmy;

      // Lose only when player has no territory and no remaining troops anywhere.
      if (humanTiles === 0 && humanTotalArmy <= 0) {
        gameOver = true;
        isPaused = false;
        rulesOverlay.classList.add("hidden");
        endTitle.textContent = "你输了";
        endDesc.textContent = "你的地块已全部失守。";
        endOverlay.classList.remove("hidden");
        return;
      }

      const enemyTiles = tiles.some((t) => t.owner > 0);
      const enemyFieldArmy = tiles.reduce((sum, t) => sum + (t.owner > 0 ? t.army : 0), 0);
      const enemyMarchingArmy = troopMarches.reduce((sum, m) => sum + (m.attackerId > 0 ? m.units : 0), 0);
      const enemyTotalArmy = enemyFieldArmy + enemyMarchingArmy;

      // Neutral white tiles are not player factions: win when all enemy factions are eliminated.
      if (humanTiles > 0 && !enemyTiles && enemyTotalArmy <= 0) {
        gameOver = true;
        isPaused = false;
        rulesOverlay.classList.add("hidden");
        endTitle.textContent = "你赢了";
        endDesc.textContent = "你征服了全部地块。";
        endOverlay.classList.remove("hidden");
      }
    }

    function setPauseState(nextPaused) {
      isPaused = Boolean(nextPaused) && gameStarted && !gameOver;
      pauseBtn.textContent = isPaused ? "继续游戏" : "暂停游戏";
    }

    function showHome() {
      window.location.href = "./index.html";
    }

    function openConfig(mode) {
      gameMode = mode;
      configTitle.textContent = mode === MODE_HUMAN_VS_AI ? "人机对战" : "AI 对战";
      configDesc.textContent = mode === MODE_HUMAN_VS_AI
        ? "你控制青色阵营，其他阵营由 AI 控制。"
        : "所有阵营都由 AI 自动对战。";
      playerCountLabel.textContent = mode === MODE_HUMAN_VS_AI ? "玩家数 m" : "AI 数量";
      homeOverlay.classList.add("hidden");
      rulesOverlay.classList.add("hidden");
      endOverlay.classList.add("hidden");
      configOverlay.classList.remove("hidden");
      refreshTileLimitUI();
      tileCountInput.value = String(tileCount);
      playerCountInput.value = String(playerCount);
    }

    function resetGame() {
      gameOver = false;
      gameStarted = true;
      setPauseState(false);
      growthTimer = 0;
      clearSelection();
      updateMapLayout(true);
      clearTroopMarches();
      createPlayers();
      createTiles();
      resetOwnership();
      updateHud();
      rulesOverlay.classList.add("hidden");
      homeOverlay.classList.add("hidden");
      configOverlay.classList.add("hidden");
      endOverlay.classList.add("hidden");
      gameControls.classList.remove("hidden");
    }

    function animate(ts) {
      requestAnimationFrame(animate);
      if (!lastTime) lastTime = ts;
      const dt = Math.min(0.05, (ts - lastTime) / 1000);
      lastTime = ts;

      if (gameStarted && !gameOver && !isPaused) {
        growArmy(dt);
        regenMoveCharges(dt);
        aiThink(dt);
        updateTroopDispatchQueues(dt);
        updateTroopMarches(dt);
        checkGameState();
        updateHud();
      }

      refreshSelectionVisuals();
      updatePathLines();
      renderer.render(scene, camera);
    }

    function onPointerDown(e) {
      if (!gameStarted || gameOver || isPaused || !hasHumanPlayer()) return;
      const tile = getTileFromPointer(e.clientX, e.clientY);
      const onOwnTile = tile && tile.owner === 0;

      if (!onOwnTile) return;

      pressing = true;
      dragging = false;
      pressStartTime = performance.now();
      pressTile = tile;
      hoveredTile = tile;
    }

    function onPointerMove(e) {
      if (!gameStarted || gameOver || isPaused || !hasHumanPlayer()) return;

      const tile = getTileFromPointer(e.clientX, e.clientY);
      hoveredTile = tile;
      const now = performance.now();

      if (pressing && !dragging && pressTile && now - pressStartTime >= LONG_PRESS_MS) {
        dragging = true;
        selectedTileIds.clear();
        selectedTileIds.add(pressTile.id);
      }

      if (!dragging) return;
      dragCursorPoint = getGroundPointFromPointer(e.clientX, e.clientY);

      if (tile && tile.owner === 0) {
        selectedTileIds.add(tile.id);
      }
    }

    function onPointerUp(e) {
      if (!gameStarted || gameOver || isPaused || !hasHumanPlayer()) return;

      if (dragging) {
        hoveredTile = getTileFromPointer(e.clientX, e.clientY) || hoveredTile;
        humanSend();
      }

      clearSelection();
    }

    function onWheel(e) {
      if (!gameStarted || gameOver || isPaused) return;
      e.preventDefault();
      const offset = camera.position.clone().sub(cameraTarget);
      const nextDist = THREE.MathUtils.clamp(offset.length() * (1 + e.deltaY * 0.0012), cameraMinDist, cameraMaxDist);
      offset.setLength(nextDist);
      camera.position.copy(cameraTarget).add(offset);
      camera.lookAt(cameraTarget);
    }

    function onResize() {
      const prevCompact = compactUI;
      compactUI = window.innerWidth <= 768;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      pathMaterial.resolution.set(window.innerWidth, window.innerHeight);
      updateMapLayout(false);
      refreshTileLimitUI();
      if (prevCompact !== compactUI) {
        rebuildTroopParticleGeometry();
        for (const tile of tiles) updateLabel(tile);
      }
    }

    humanModeBtn.addEventListener("click", () => openConfig(MODE_HUMAN_VS_AI));
    aiModeBtn.addEventListener("click", () => openConfig(MODE_AI_VS_AI));

    rulesBtn.addEventListener("click", () => {
      homeOverlay.classList.add("hidden");
      configOverlay.classList.add("hidden");
      rulesOverlay.classList.remove("hidden");
    });
    closeRulesBtn.addEventListener("click", showHome);
    rulesOverlay.addEventListener("click", (e) => {
      if (e.target === rulesOverlay) showHome();
    });

    cancelConfigBtn.addEventListener("click", showHome);

    startBtn.addEventListener("click", () => {
      const maxTiles = getMaxTileCountByArea();
      tileCount = clampInt(Number(tileCountInput.value || 24), 8, maxTiles);
      playerCount = clampInt(Number(playerCountInput.value || 4), 2, 10);
      playerCount = Math.min(playerCount, tileCount);
      tileCountInput.max = String(maxTiles);
      playerCountInput.value = String(playerCount);
      resetGame();
    });

    restartBtn.addEventListener("click", () => openConfig(gameMode));
    endHomeBtn.addEventListener("click", showHome);

    pauseBtn.addEventListener("click", () => {
      if (!gameStarted || gameOver) return;
      setPauseState(!isPaused);
    });
    restartGameBtn.addEventListener("click", () => {
      if (!gameStarted) return;
      setPauseState(true);
      openConfig(gameMode);
    });
    backHomeBtn.addEventListener("click", showHome);

    renderer.domElement.addEventListener("pointerdown", onPointerDown);
    renderer.domElement.addEventListener("pointermove", onPointerMove);
    window.addEventListener("pointerup", onPointerUp);
    renderer.domElement.addEventListener("wheel", onWheel, { passive: false });
    renderer.domElement.addEventListener("contextmenu", (e) => e.preventDefault());
    window.addEventListener("resize", onResize);

    updateMapLayout(true);
    updateHud();
    rebuildTroopParticleGeometry();
    openConfig(MODE_HUMAN_VS_AI);
    animate(0);
  </script>
</body>
</html>
